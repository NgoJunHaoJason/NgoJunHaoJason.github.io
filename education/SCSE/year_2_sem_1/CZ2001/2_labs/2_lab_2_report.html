<!DOCTYPE html>

<html>
<!--remember to include the following for mobile-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
    <title>Report | Lab 2 | CZ2001 | Jason Ngo's website</title>

    <link rel="icon" href="../../../../../images/sciurus_96.png">
    <link rel="stylesheet" type="text/css" href="../../../../../styles/default_style.css">

    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>

<body>
    <h2 class="header">
        CZ2001 Algorithms
    </h2>

    <!--start of nav-related code-->
    <ul class="navbar">
        <li>
            <a href="../../../../../index.html">
                home
            </a>
        </li>

        <li>
            <a href="../../../../main.html">
                education
            </a>
        </li>

        <li>
            <a href="../../../../../experience.html">
                experience
            </a>
        </li>

        <li>
            <a href="../../../../../miscellaneous/main.html">
                miscellaneous
            </a>
        </li>
    </ul>
    <!--end of nav-related code-->

    <!--start of content-related code-->
    <div class="content">
        <h3>Example Class 2 Report</h3>

        <p><u>Background</u></p>

        <p>
            In the new age of consumerism, where the sale of goods is incumbent on the speed and convenience of shopping
            on e-commerce sites, we are witnessing the exponential increase in the variety and stock of products that
            are available online.
        </p>

        <p><u>Problem</u></p>

        <p>
            Correspondingly, there is a pressing need for an appropriate implementation of the inventory database for
            e-commerce sites to keep the items and its relevant information neatly stored and easily accessible for
            employees.
        </p>

        <p><u>Data Set</u></p>

        <p>
            A collection of 20,000 products listed on Flipkart.
        </p>

        <p><u>Solution</u></p>

        <p>
            We have designed a program in Java, whose function is to store the product details in hash tables through
            the implementation of a hashing function.
        </p>

        <p>
            By using this method, employees would quickly be able to retrieve the exact specified product by searching
            up for the key in the hash table, thus solving the accessibility problem.
        </p>

        <p>
            <ul>
                <li>
                    Constraint: Use only closed address hashing.
                </li>
            </ul>
        </p>

        <p><u>Hashing Algorithm and Implementation</u></p>
        <p>
            Task: Compare between hash tables of prime and non-prime sizes
        </p>

        <p>
            We used the folding method as follow for our implementation of the hashing function:
            <ol>
                <li>
                    Convert the product serial number is converted to String type.
                </li>
                <li>
                    Multiply each character in the product serial number by its own position in the string.
                </li>
                <li>
                    Sum all of the values obtained in step 2 to get the key.
                </li>
                <li>
                    Pass the key through a hash function to obtain the value.
                    <ul>
                        <li>
                            hash(key) = key % hashTableSize
                        </li>
                        <li>
                            hashTableSize &isin; [20,500]
                        </li>
                    </ul>
                </li>
            </ol>
        </p>

        <p><u>Testing</u></p>

        <p>
            TODO
        </p>

        <p><u>Statistics</u></p>

        <p>
            TODO: results (and visualisation)
        </p>

        <p><u>Time Complexity</u></p>

        <p>
            Let <i>n</i> be number of keys, and <i>h</i> be number of slots(linked lists) in the hash table.
        </p>

        <p>
            For closed address hashing, the worst case scenario occurs when the keys are all placed in the same slot in
            the hash table, forming one linked list of length <i>n</i>. An unsuccessful search will iterate through the
            entire linked list to do <i>n</i> number of comparisons, resulting in a time complexity of
            &theta;(<i>n</i>). For a successful search, assuming an equal probability of a key being stored anywhere in
            the linked list, the number of comparisons required to find a key on average is given by (sum of time taken
            to reach each node)/<i>n</i>, which will result in a time complexity of &theta;(<i>n</i>).
        </p>

        <p>
            The average case occurs when any key has equal probability of being hashed into any of the slots in the hash
            table. An unsuccessful search still involves iterating through an entire linked list. However, since the
            keys are assumed to be evenly distributed across the hash table, the linked lists would have a length of
            <sup><i>n</i></sup>/<sub><i>h</i></sub> on average which means doing <sup><i>n</i></sup>/<sub><i>h</i></sub>
            comparisons on average, resulting in a time complexity of
            &theta;(<sup><i>n</i></sup>/<sub><i>h</i></sub>).
        </p>

        <p>
            For a successful search, the key would be found 1 node after the previous node in the linked list where it
            was inserted. If the key to be found is the ith item to be inserted, then the length of the linked list from
            head to that previous node is given by <sup>(<i>i</i>-1)</sup>/<sub><i>h</i></sub>. Since, the key is 1 node
            after that previous node, its length is 1 node longer, so the number of comparisons required to reach it is
            1 + <sup>(<i>i</i>-1)</sup>/<sub><i>h</i></sub>.
        </p>

        <p>
            The average number of comparisons for <i>n</i> number of keys can be obtained by summing up the number of
            comparisons for each key, 1 + <sup>(<i>i</i>-1)</sup>/<sub><i>h</i></sub>, and dividing the sum by the
            number of keys. This results in a time complexity of &theta;(1 + <sup><i>n</i></sup>/<sub><i>h</i></sub>).
            If <i>n</i> is directly proportional to <i>h</i>, the time complexity is in fact O(1).
        </p>

        <p>
            For this task, we varied the number of keys to be stored in the hash table based on the hash table size and
            predetermined load factors, so <i>n</i> is always directly proportional to <i>h</i>. For hash tables of
            prime sizes, regardless of the distribution of key values, the keys should be evenly distributed over the
            table, so searching for a key tends to be an average case. However, for hash table of non-prime sizes, if
            the distribution of key values is not random, there would to be more collision, resulting in longer linked
            lists and more worst cases.
        </p>

        <p><u>Conclusion</u></p>

        <p>
            For an implementation of an efficient hash table, collisions should be minimized as much as possible. Using
            primes for hash tables is a good idea because it minimizes clustering in the hash table. It is also the most
            convenient for growing a hash table in the face of expanding data.
        </p>

        <p>
            However, the test scenarios in this example case have shown that hash table size of prime numbers have
            returned mixed results. This could be largely attributed to the fact that the selection of items have been
            made wholly random, when in reality, the distribution of data tends to exhibit a pattern which would lead to
            clustering and collision in the hash table.
        </p>

        <p>
            A blind understanding of the theory of using hash tables of prime sizes may also lead one to conclude that
            the larger the value of the prime number, the better the hash table would perform.
        </p>

        <p>
            However, the results of the experiment have once again reminded us of the imperative need to apply the
            theory in context. For instance, with a collection of 20,000 product serial numbers, it would be
            counter-productive to use 20,011 (which is also a prime number) as the size of the hash table, as much as it
            is inapplicable.
        </p>

        <p><u>Additional Comments</u></p>

        <p>
            The function searchProduct() has a boolean parameter that controls whether to print the starting time,
            ending time, execution time, as well as whether a product’s key can be found in a hash table. Normally,
            these print statements are unnecessary in a searching function since its primary purpose is to search.
            However, we find the without these print statements, the execution times obtained in the result csv files
            generated are mostly 0: the computer searches through the hash tables so fast that it seems to take no time
            to search, even when using a measurement scale of nanoseconds. As such, we needed these print statements to
            slow down the search function significantly enough for us to capture the results.
        </p>

        <p>
            For the case of unsuccessful searches, we generate random strings of 32 characters (to match the format of
            the products’ serial numbers), of which each character has an equal probability of an alphanumeric value
            (1-9, a-z, A-Z), to be used as the target keys to search for. For the search to be unsuccessful, these
            target keys generated have to not match any of the keys in the hash table. The random string generator
            function does not account for the existing keys stored in the hash table, so there is a possibility that a
            target key generated end up being the same as a key stored in the hash table. However, we deemed this
            possibility to be insignificant, as there are (10+26+26)<sup>32</sup> = 62<sup>32</sup> combinations of strings that can be
            generated, of which only 20 000 would already exist in the data set. Even if keys of the entire data set are
            stored in the hash table, the probability of getting 2 strings that match is <sup>20000</sup>/<sub>62<sup>32</sup></sub> = 8.8e<sup>-54</sup>, which is
            a very, very small probability. We ran the searches multiple times, for various load factors, for hash
            tables of various hash size, so even if we have one anomalous data, the rest of the data will average the
            error out.
        </p>

        <h3>Authors</h3>
        <p>
            SE1 (Group 2)
            <ul>
                <li>LYZ</li>
                <li>Ngo Jun Hao Jason</li>
                <li>TSF</li>
                <li>TYHK</li>
                <li>YHL</li>
            </ul>
        </p>
    </div>
    <!--end of content-related code-->

    <!--start of nav-buttons code-->
    <div class="nav-buttons">
        <a href="../main.html">
            back
        </a>
    </div>
    <!--end of nav-buttons code-->

    <!--start of footer-related code-->
    <div class="footer">
        <div class="github">
            <img src="../../../../../images/GitHub-Mark-120px-plus.png">

            <a target="_blank" href="https://github.com/NgoJunHaoJason">
                GitHub profile
            </a>
        </div>

        <div class="last-modified">
            last modified:
            <span id="last_modified">null</span>
        </div>
    </div>
    <!--end of footer-related code-->

    <script defer="defer" src="../../../../../scripts/on_page_load.js"></script>
</body>

</html>